Module 05
- `The soul of a new machine`
- the computer `ENIAC`
	- static sort: the order of sort
- fast to use hashset
## Linked list

// Interface IListOfBooks
```java
/**
 * This interface represents all the operations to be supported by a list of
 * books
 */
public interface IListOfBooks {
  int count();
  float totalPrice();
  IListOfBooks allBefore(int year);
  IListOfBooks sortByPrice();
  String toString();
}

public class EmptyNode implements IListOfBooks {

}

public class ElementNode implements IListOfBooks {
  private Book data;
  private IListOfBooks rest;
}
```

// class EmptyNode
```java
@Override
public int count(){return 0};

//the base case
public String toString() { return "";}
```

// class ElementNode
```java
@Override
public int count() {
    return 1 + this.rest.count();
}

@Override
public String toString() {
	return "("+this.book.toString()+")"+this.rest.toString();
}
```

### predicates
A predicate: when you apply it to something, it evaluates to `true` or `false`.
- allBefore versus allBefore vs allCheaperThan
create an interface
```java
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        // Define a Predicate that checks if a number is even
        Predicate<Integer> isEven = x -> x % 2 == 0;

        // Use .test() to evaluate the predicate
        System.out.println("isEven.test(4): " + isEven.test(4)); // true
        System.out.println("isEven.test(5): " + isEven.test(5)); // false

        // Another Predicate: check if number > 10
        Predicate<Integer> greaterThanTen = x -> x > 10;

        System.out.println("greaterThanTen.test(8): " + greaterThanTen.test(8));   // false
        System.out.println("greaterThanTen.test(20): " + greaterThanTen.test(20)); // true

        // Combine predicates: isEven AND greaterThanTen
        Predicate<Integer> evenAndGreaterThanTen = isEven.and(greaterThanTen);

        System.out.println("evenAndGreaterThanTen.test(8): " + evenAndGreaterThanTen.test(8));   // false
        System.out.println("evenAndGreaterThanTen.test(12): " + evenAndGreaterThanTen.test(12)); // true
    }
}

```
### Generics
Eg: make a list of books or a list of integers
- a collection of `<GivenDataType>`

```java
ArrayList<String> list = new ArrayList<>();
```

### Abstract Data Type  (ADT)
Q: What is the relationship between ADT and Java interface?
- But in Java, we usually **use an interface to express an ADT**, because both only describe _what can be done_ without saying _how it is done_.

### Predicate Abstraction
```java
public class Bookbefore
```

#### Abstraction Sorting
```java
Comparable<T> interface supports
```

```java
// 1. 2010 year befor 2010
IListOfBooks oldBooks = list.getList(b -> b.getYear() < 2010);

// 2. all price less than 50
IListOfBooks cheapBooks = list.getList(b -> b.getPrice() < 50);

// 3. all author is "Robert Martin"
IListOfBooks uncleBobBooks = list.getList(b -> b.getAuthor().equals("Robert Martin"));
```

## Predicate `Predicate<Book>`

like an interface
```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```
## 4. **Generics** Class
- 用类型参数 `<T>` 来写通用代码。
- 好处：不用为 `Book`、`Integer`、`String` 分别写一套链表。
- Eg:
```java
public class Box<T> {
    private T value;

    public Box(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

Box<String> stringBox = new Box<>("Hello");
Box<Integer> intBox = new Box<>(123);
```
    
- `<T>` 表示链表存的类型，调用时具体化：
    - `GenericListADTNode<Book>` → 存书
    - `GenericListADTNode<Integer>` → 存整数

## 5. **`Predicate<T>`**

- Predicate 就是一个“条件函数”，输入一个对象，return 它是否符合条件
- 方法：
    `boolean test(T t);`
- 输入一个对象 → 返回 `true` 或 `false`。
- 常用来做过滤：
    `Predicate<Book> cheap = b -> b.getPrice() < 50; list.getList(cheap); // 返回便宜书`
    
- 可以组合：`.and()`, `.or()`, `.negate()`。


```java
Predicate<Book> cheapBook = b -> b.getPrice() < 50;
```

---

## 6. Comparable Interface **`Comparator<T>`**

## Anonymous Classes and lambdas

| Feature               | Anonymous Class                                                       | Lambda Expression                                                             |
| --------------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Syntax**            | `new Interface() { ... }`                                             | `(args) -> { body }`                                                          |
| **Class name**        | Has an implicit anonymous inner class                                 | No class, only a function implementation                                      |
| **Methods supported** | Can implement multiple methods (including overriding default methods) | Can only be used with **functional interfaces** (exactly one abstract method) |
| **Code verbosity**    | Verbose, must repeat interface name and method signature              | Concise, just parameters and body                                             |
| **Common usage**      | Swing listeners, legacy code, non-functional interfaces               | Stream API, `Predicate`, `Comparator`, `Runnable`                             |
## Comparator Interface
 - `Comparator<T> interface`
- `compare(T a, T b)`

Q: What is the different between **comparator** and **compare**?
Both are method signatures defined by **Java’s built-in interfaces**
- comparator
	- `Comparator<T>` is a **functional interface** in Java.
	-  **Comparator** = the interface/type (a strategy for ordering).
- compare
	- `compare(T o1, T o2)` is the **method inside the Comparator interface**.
	- **compare** = the method inside that interface which actually compares two objects.
## Three examples of higher-order abstractions:
- filter
- fold/reduce
- map

## Exception
key words:
- try, catch, finally, throw, throws

- IllegalArgumentException

- someCheckedException: outside
- someUncheckedException: bug

```java
public void divide(int a, int b) {
    if (b == 0) {
        throw new IllegalArgumentException("Denominator cannot be zero!");
    }
    System.out.println(a / b);
}

public class TestDivide {
    public static void main(String[] args) {
        try {
            divide(10, 0); 
        } catch (IllegalArgumentException e) {
            System.out.println("Caught exception: " + e.getMessage());
        } finally {
            System.out.println("Finally block always runs.");
        }
    }
}
```

```java
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path); 
}
```