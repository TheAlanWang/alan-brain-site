- equal
## Equal
1. **Reflexivity:** A is equal to A (every object is equal to itself).
2. **Symmetry:** If A is equal to B, then B is equal to A.
3. **Transitivity:** If A is equal to B and B is equal to C, then A is equal to C.

```java
class Person {
    String name;
    Person(String name) { this.name = name; }

    @Override
    public boolean equals(Object obj) {
    // short circuit: is o the same as this one
        if (this == obj) return true;
	    
	    //is the same type
        if (!(obj instanceof Person)) return false;
        
        // cast to the correct type
        Person p = (Person) obj;
        
        // below is the actual same
        return name.equals(p.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}
```

```java
public boolean equals(Object obj){

	if (this == obj) return true;
	
	if (!(obj instanceof Book)) return false;
	
	Book other = (Book) obj;
	
	return this.title.equals(other.title)
		&& this.author.equals(other.author)
		&& Math.abs(this.price - other.price) < 0.01
	}
```

### Lesson3

**Symmetry**

square `public class Square extends Rectangle {}`

 If you provide a default implementation in `AbstractShape`
 ```java
public abstract class AbstractShape {     
	public boolean equalsCircle(Circle other) {         
		return false; // default rule: non-circles are never equal to circles     
	} 
}
 ```

Advantages:
- Subclasses are **not forced** to override it.
- Default behavior is consistent (helps symmetry).
- Subclasses that care (like `Circle`) can override it.

#### How it works — runtime dispatch:
Java uses **dynamic method dispatch**:
1. When you call `equalsCircle()`, the runtime checks the _actual object type_.
2. If the subclass overrides it → the subclass version runs.
3. If not → it falls back to the parent’s version.

Example:
```java
AbstractShape s1 = new Circle(5); 
AbstractShape s2 = new Rectangle(3, 4); 
Circle c = new Circle(5.01);  
s1.equalsCircle(c); // calls Circle’s version  
s2.equalsCircle(c); // calls AbstractShape’s default version (false) 
```

This ensures predictable and consistent behavior.

```java
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }

    if (!(o instanceof AbstractShape)) {
        return false;
    }

    return ((AbstractShape) o).equalsCircle(this);
}
```

## Lesson4
### COMPARISON

| Aspect                    | `Comparable`             | `Comparator`                                 |
| ------------------------- | ------------------------ | -------------------------------------------- |
| Defined in                | Same class               | Separate class                               |
| Method                    | `compareTo(Object o)`    | `compare(Object o1, Object o2)`              |
| Used for                  | Natural/default order    | Custom / multiple orders                     |
| Number of possible orders | Only one per class       | Many (you can make multiple comparators)     |
| Example                   | `Collections.sort(list)` | `Collections.sort(list, new MyComparator())` |
#### Ordering in Java
- `Collections.sort(...)`
### Comparable CompareTo
a class that implements `Comparable` can only define **one** `compareTo()` method,  which means it only supports **one natural ordering**.

```java
import java.util.*;

public class Student implements Comparable<Student> {

    @Override
    public int compareTo(Student other) {
        // sort by roll number (ascending order)
        return this.rollno - other.rollno;
        // OR safer: return Integer.compare(this.rollno, other.rollno);
    }
}
```

### Comparator
Q: What if you want to sort differently? use `Comparator`

```java
Comparator<Student> byName = (a, b) -> a.name.compareTo(b.name);
Comparator<Student> byRoll = (a, b) -> Integer.compare(a.rollno, b.rollno);
Comparator<Student> byLengthOfName = (a, b) -> a.name.length() - b.name.length();
```


## Lesson4 binary search

```java
import java.util.Comparator;

public class Searches {
  public static <T> boolean binarySearch(T[] array, T value, Comparator<? super T> comparator) {
    int low = 0, high = array.length - 1;

    while (low <= high) {
      int mid = low + (high - low) / 2;              // avoid overflow
      int cmp = comparator.compare(value, array[mid]);

      if (cmp == 0) {
        return true;                                  // found
      } else if (cmp < 0) {
        high = mid - 1;                               // value < array[mid]
      } else {
        low = mid + 1;                                // value > array[mid]
      }
    }
    return false;                                     // not found
  }
}
```

## Lesson5 selectionSort
```java
public static <T> void selectionSort(T[] arr, Comparator<T> comparator) {
    for (int k = arr.length - 1; k >= 1; k = k - 1) {
        // find the maximum in arr[0..k]
        int maxindex = 0;
        for (int j = 1; j <= k; j++) {
            if (comparator.compare(arr[j], arr[maxindex]) > 0) {
                maxindex = j;
            }
        }
        // swap the maximum with arr[k]
        swap(arr, maxindex, k);
    }
}
```

helper
```java
private static <T> void swap(T[] arr, int i, int j) {
    T temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

## Lesson7 MergeSort

## Lesson 8 orderSet

```java
import java.util.Set;
import java.util.TreeSet;

Set<String> usernames = new TreeSet<>();
```

### hash table
```java
@Override 
public int hashCode() { 
	return Objects.hash(firstName,lastName,yearOfBirth); 
}
```

- Q: What is `hashCode()` in Java?
	- In Java, every class automatically inherits a method from `java.lang.Object` called:
	- `public int hashCode()`
	- It returns an **integer** (the hash value) that represents the object in memory.

- Q: What’s the purpose?
	- The hash code is used to make **searching and storing objects fast**  in data structures like:
	- `HashMap`, `HashSet`, `HashTable`, `ConcurrentHashMap`

