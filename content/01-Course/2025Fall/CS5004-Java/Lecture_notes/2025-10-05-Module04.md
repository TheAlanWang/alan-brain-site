- Accumulated Design
## Static data
- every time create a class，count +1
- That means **all objects of the class share the same single static variable**.
```java
public class Student {
    private String name;
    // static variable：all class has a one static variable
    public static int count = 0;

    public Student(String name) {
        this.name = name;
        count++; // every time create a class，count +1
    }

    public String getName() {
        return name;
    }
}
```

## Demo book

Create `IListOfBook` Interface
- Q: What is an interface?
	- `interface`is like a *contract* or blueprint.

- Q: Why can an interface return an interface?
	- An interface is not an object
	- Returning an interface really means returning an object of some implementing class
	- This is about abstraction and decoupling.

```java
public interface IListOfBooks {
  IListOfBooks allBefore(int year);
  IListOfBooks sortByPrice();
}
```

next to implement interface in `ElementNode` and `EmptyNode`
```java
public class ElementNode implements IListOfBooks{
  private Book book;
  private IListOfBooks rest;

  public ElementNode (Book book, IListOfBooks rest){
    this.book = book;
    this.rest = rest;
  }

  @Override
  public int count(){
    return 1 + this.rest.count();
  }

  @Override
  public float totalPrice(){
    return this.book.getPrice() + this.rest.totalPrice();
  }

  @Override
  public IListOfBooks allBefore(int year){
    if (this.book.before(year)){
      return new ElementNode(this.book, this.rest.allBefore(year));
    } else {
      return this.rest.allBefore(year);
    }
  }

  @Override
  public IListOfBooks insert(Book book) {
    if (this.book.cheaperThan(book)) {
      return new ElementNode(this.book, this.rest.insert(book));
    } else {
      return new ElementNode(book, this);
    }
  }

  @Override
  public IListOfBooks sortByPrice() {
    return this.rest.sortByPrice().insert(this.book);
  }

}
```

- Q: How `allBefore` and `sortByPrice` method work?
	- The `if` condition in `allBefore` is normal control flow inside `ElementNode`.    
	- The **recursive call** to `rest.allBefore(...)` or `rest.sortByPrice()` is the **dynamic dispatch** part, because the actual implementation chosen depends on whether `rest` is `ElementNode` or `EmptyNode`.
- Q: What is **dynamic dispatch**?
	- At **runtime**, Java chooses which method implementation to execute, based on the actual object type, not the variable type.

## Accumulate Based Design(with tail call)
```java
int count() {return countHelp(0);}

// accumulate design
int countHelp(int acc) {
    if (this instanceof EmptyNode) return acc;
    else return rest.countHelp(acc + 1); // tail-recursion
}
```
- **Accumulate Design**
	- An **accumulator** is a parameter that **stores intermediate results** during recursion  so we don’t need to recompute them later.
	
- Q: What is the purpose of *`accumulator helper`*?
	- Tail-recursion:
	- Its purpose is to store the **intermediate** result (the accumulated value) during recursion and return the final result once recursion finishes.

- Q: What is tail recursion?
	- it means the **recursive call is the very last thing the function does** before returning.
	- Tail recursion: eg: `return rest.countHelp(acc + 1);`
		- no other work after the call.
	- Not tail recursion: `return 1 + rest.count();` -> after recursion need to add 1

## Filter
### total price
```java
  public float totalPrice() {
    return this.book.getPrice() + this.rest.totalPrice();
  }
```

### filter year
```java
// ElementNode
  public IListOfBooks allBefore(int year) {
    if (this.book.before(year)) {
      return new ElementNode(this.book, this.rest.allBefore(year));
    } else {
      return this.rest.allBefore(year);
    }
  }
  
```

## Sort
`sort by price + insert`
there are two books:
- **`this.book`** → The book stored in the **current node** — the “old” book that’s already in the linked list.
- **`book`** → The **new book** you want to insert — it’s the one passed in as a parameter and not yet in the list.
```java
// ElementNode
@Override
  public IListOfBooks sortByPrice() {
    return this.rest.sortByPrice().insert(this.book);
  }

@Override
  public IListOfBooks insert(Book book) {
    if (this.book.cheaperThan(book)) {    // node < new_book
      return new ElementNode(this.book, this.rest.insert(book)); // insert new_book into res
    } else {
      return new ElementNode(book, this); // new_book, make the current node (`this`) the rest of the list.
    }
  }

// EmptyNode
  @Override
  public IListOfBooks sortByPrice() {
    return new EmptyNode();
  }

  @Override
  public IListOfBooks insert(Book book) {
    return new ElementNode(book, this);
  }

```


If we need to write `sortbyauthor` and `sortByPrice` will be similar.
boolean taskSpecificTestMethod(Book b);

so we can use predicate
## `Predicate<T>`
### Interface `IBookPredicate` 
// interface: IBookPredicate
```java
public interface IBookPredicate {
  boolean test(Book b);
}
```

### class `predicator` 
#### class BookBefore class
```java
public class BookBefore implements IBookPredicate {
  private final int year;

  public BookBefore(int year) {
    this.year = year;
  }

  @Override
  public boolean test(Book b) {
    return b.getYear() < year;
  }
}
```
#### class BookWithAuthor
```java
public class BookWithAuthor implements IBookPredicate {
  private String authorName;

  public BookWithAuthor(String authorName) {
    this.authorName = authorName;
  }

  @Override
  public boolean test(Book b) {
    return b.getAuthor().contains(authorName);
  }
}
```

#### test predicator
```java
    IListOfBooks oldBooks = listOfBooks.getList(before2000);

    assertEquals("(Title: HP 1 Author: J.K. Rowling Year: 1997 Price: 19.99)"
        + "(Title: HP 2 Author: J.K. Rowling Year: 1999 Price: 29.99)"
        , oldBooks.toString());
```

### improve to `predicator<Book>

**`predicator<Book>`** means: A function that takes a `Book` and returns a `boolean`
	
```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}


Predicate<Book> byRowling = b -> b.getAuthor().contains("Rowling");
```

- `predicator<Book>` means:
	- A function that takes a `Book` and returns a `boolean`
// BookWithAuthor
```java
import java.util.function.Predicate;

public class BookWithAuthor implements Predicate<Book>  {
  private String authorName;

  public BookWithAuthor(String authorName) {
    this.authorName = authorName;
  }

  @Override
  public boolean test(Book b) {
    return b.getAuthor().contains(authorName);
  }
}
```

#### test
```java
  @Test
  public void testAllBeforePredicate() {
    int year = 2000;
    IListOfBooks lastCentury = listOfBooks.getList(
        new Predicate<Book>() {
          public boolean test(Book b) {
            return b.getYear() < year;   // keep books published before 2000
          }
        });
    assertEquals("(Title: HP 1 Author: J.K. Rowling Year: 1997 Price: 19.99)"
            + "(Title: HP 2 Author: J.K. Rowling Year: 1999 Price: 29.99)"
        , lastCentury.toString());
  }
```

`b -> b.getYear() < year`  
means “for every book `b`, return `true` if its year is less than `year`.”
```java
    int year = 2000;
    IListOfBooks lastCentury = listOfBooks.getList(b -> b.getYear() < year);
```

## **`Comparator<T>`**

if your class implements `Comparable<T>`, you must write (override) the `compareTo()` method`
```java
public class Book implements Comparable<Book> {
  
  public int compareTo(Book other) {
    int yearCompare = Integer.compare(this.year, other.year);
    if (yearCompare != 0) {
      return yearCompare; // earlier year comes first
    }

    int priceCompare = Float.compare(this.price, other.price);
    if (priceCompare != 0) {
      return priceCompare; // cheaper book comes first
    }
    
    return this.title.compareTo(other.title);
  }

}  
```

## Higher-Order Abstractions
A **higher-order function** is a function that **takes another function as an argument** and/or returns a function as a result.

| Function          | Type           | Description                          | Example             |
| ----------------- | -------------- | ------------------------------------ | ------------------- |
| **filter**        | `List → List`  | Keeps elements that meet a condition | Books before 2000   |
| **map**           | `List → List`  | Transforms each element              | Get all book titles |
| **fold / reduce** | `List → Value` | Combines all elements into one value | Count total price   |
- **filter**
	- `IList filter(IList input, Predicate p);`
- **map**
	- `IList map(IList input, Function func);`
- **fold/reduce**
	- `SummaryType fold(IList input, FoldFunction func, SummaryType init);`

```
average = fold(
              filter(
                  map(listOfUsers, "findGenderPosts"),
                  "gender = female"),
              "build-average")
```

lesson 10
## ADT
```
Client (users)
   ↓
BookListADT (interface)
   ↓ implements
BookListADTImpl (class)
   ↓ contains
BookListADTNode (interface) head 
          ↑
          ├── BookListADTElementNode
          └── BookListADTEmptyNode

```

// BookListADTElementNode
```java
  @Override
  public Book get(int index) throws IllegalArgumentException {
    if (index < 0) {
      throw new IllegalArgumentException("Invalid index: " + index);
    }
    if (index == 0) {
      return this.book;
    }
    return this.rest.get(index - 1);
  }
```

In the recursive logic, every time you move one node forward, the `index` decreases by 1.

## Generics
```java
public class BookListADTImpl implements BookListADT {
  private BookListADTNode head; // the head of the list

  public BookListADTImpl() {
    this.head = new BookListADTEmptyNode();
  }
```

improve to `ListADTImpl`
```java
public class ListADTImpl<T> implements ListADT<T> {
  private GenericListADTNode<T> head;

  public ListADTImpl() {
    head = new GenericEmptyNode<>();
  }

  @Override
  public void addFront(T b) {
    head = head.addFront(b);
  }
  ...
}

```

### create generics interface
```java
<R> GenericListADTNode<R> map(Function<T,R> converter);
```

 `<T>` and `<R>` are two different type parameters
- **`T`** → the type of data currently stored in the list (**input type**)
- **`R`** → the type of data after applying the `map()` transformation (**output type**)

- `GenericListADTNode<T>` → a node that stores a value of type `T`
- `T` → “the _value_ stored inside that node”

## Arrays
```java
int[] a = {2,3,1,5};
int[] b = new int[5];

```

## Higher-Order Functions & Lambda Forms
```java
List<String> allTitles = new LinkedList<String>(); // create empty LinkedList


// Accomplishing this with a for-each loop
for (Book b : bookList) {
    allTitles.add(b.getTitle());
}

List<String> allTitles = 
    bookList.stream()
            .map(b -> b.getTitle())
            .collect(Collectors.toList());
            
// map
double totalPrice = 0;

// method 01
for (Book b : bookList) {
    totalPrice += b.getPrice();
}
assertEquals(59.96, totalPrice, 0.01);

// method 02
double totalPrice = bookList.stream()
                            .mapToDouble(b -> b.getPrice())
                            .sum();
// method 03                            
double totalPrice = bookList.stream()
                            .mapToDouble(b -> b.getPrice())
                            .reduce(0, (a, b) -> a + b);
assertEquals(59.96, totalPrice, 0.01);

```

### Combine
```java
// method 01
double totalPrice = 0;
for (Book b : bookList) {
    if (b.getYear() < 2000) {
        totalPrice += b.getPrice();
    }
}
assertEquals(43.97, totalPrice, 0.01);

// method 02
totalPrice = bookList.stream()
                     .filter(b -> b.getYear() < 2000)
                     .mapToDouble(b -> b.getPrice())
                     .sum();
assertEquals(43.97, totalPrice, 0.01);

```