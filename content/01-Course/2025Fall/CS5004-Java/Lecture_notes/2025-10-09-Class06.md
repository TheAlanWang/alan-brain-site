**Mid-term**
Download: `org.junit.jupiter:junit-jupiter:5.10.0`

- Thursday 10/16/2025
- Some provided code might have latent bugs.
	- find and describe bugs
	- fix bugs
- some multiple-choice questions

Comparable and Comparator interface in Java
`
```java
public class Student implements Comparable<Student> { //I can compare myself to some object of type `T`
    private int score;

    public Student(int score) {
        this.score = score;
    }

    @Override
    public int compareTo(Student other) { // T = Student
        return this.score - other.score;
    }
}
```


```java
public class Student<T> implements Comparable<T> {}
```

### Comparable & Comparator

|                   | Comparable                                                                       | Comparator                                            |
| ----------------- | -------------------------------------------------------------------------------- | ----------------------------------------------------- |
| Definition        | Implemented **inside the class itself**                                          | Defined **externally (outside the class)**            |
| Method            | `compareTo()`                                                                    | `compare()`                                           |
| Method Parameters | One parameter — compares the **current object** (`this`) <br>with another object | Two parameters — compares **object1** and **object2** |
| Usage             | `Collections.sort(list)`                                                         | `Collections.sort(list, comparator)`                  |
| Flexibility       | Fixed **one sorting rule**                                                       | Can define **multiple sorting rules**                 |
| Example           | `Student implements Comparable<Student>`                                         | `Comparator<Student> byScore = ...`                   |

```java
Comparator<Student> byScoreDesc = (s1, s2) -> s2.score - s1.score;
Collections.sort(list, byScoreDesc);
```


overwriting and overloading

|Term|Simple meaning|
|---|---|
|**Overloading**|Same method name, **different parameters**, **same class**.|
|**Overriding**|Same method name, **same parameters**, **child class replaces parent’s version**.|

equal
```java
@Override
public boolean equals(Object object){
	if (object == this) {return true;}
	if (object == null) {return false;}
	if (!(object instanceof Book)) {return false;}
	
	Book book = (Book) object;
	return this.name.equals(book.name) && this.year == book.year;
}
```


Reflect
```java
public class Circle {
    public boolean equalsCircle(Object obj) {
        return obj instanceof Circle;
    }
}
```

**Hash table**
```java
import java.util.HashMap;

public class Example {
    public static void main(String[] args) {
        // Create a hash table (HashMap)
        HashMap<String, Integer> map = new HashMap<>();

        // Add key-value pairs
        map.put("Alice", 90);
        map.put("Bob", 85);
        map.put("Charlie", 95);

        // Get a value by key
        System.out.println(map.get("Alice")); // 90

        // Check if key exists
        System.out.println(map.containsKey("Bob")); // true

        // Remove a key
        map.remove("Bob");

        // Loop through all keys
        for (String name : map.keySet()) {
            System.out.println(name + " -> " + map.get(name));
        }
    }
}
```

### hashCode and equals
```java
@Override
public int hashCode(){
	return Objects.hash(firstName, lastName, yearOfBirth);
}
```

## Mid-term
- Information Hiding
- Encapsulation
- Polymorphism
- Inheritance
	- composition(point 2-D)

- hashCode and equals

testing
- each assertion is a test(not count `@test`)
- black box testing
- camelCase

javadoc

case-swith:
- need -> `break`

```java
public abstract class AbstractShape implements Shape {
  protected Point2D reference;

  public AbstractShape(Point2D reference) {
    this.reference = reference;
  }
```

| Modifier    | Same Package Access | Subclass Access (Different Package) | Other Package Access (No Inheritance) |
| ----------- | ------------------- | ----------------------------------- | ------------------------------------- |
| `private`   | ❌                   | ❌                                   | ❌                                     |
| default     | ✅                   | ❌                                   | ❌                                     |
| `protected` | ✅                   | ✅                                   | ❌                                     |
| `public`    | ✅                   | ✅                                   | ✅                                     |

A class may extend **only** one class, but can implement *multiple interface*.

`LinkedArray predicator<T>`


`built-in List<E>`
```java
List<String> names = new ArrayList<>();
names.add("Alan");
names.add("Bob");
names.add("Charlie");
System.out.println(names.get(1)); // Bob
```

Abstracting out the predicate for filter

IListFilter(IList input, Predicate p);

Higher-order Abstractions

`Predicate<T>`
- Represents a **"boolean condition"** or **"test logic"**.
- It takes an object of type `T` and returns ✅ whether the object meets the condition (`true` or `false`).