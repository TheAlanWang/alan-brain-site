## Terminal
```zsh
ssh alanwang166@login.khoury.northeastern.edu

mkdir cs5008

vim simple.asm // Edited or created a `simple.asm` file using Vim.

cat simple.asm

nasm -f elf64 simple.asm -o simple.o
ld simple.o -o simple
./simple; echo $?
```
### assembly code - `simple.asm`
```zsh
[alanwang166@login-students class3]$ cat simple.asm

global _start

_start:
    mov rax, 60     ; put 60 into rax
    mov rdi, 42     ; put 42 into rdi
    syscall         ; make a Linux system call
```

Explain:
- `global _start`
    - Declares `_start` as a **global symbol**.
    - Tells the linker: the program’s entry point is at `_start`.    
    - In C, the entry point is `main`; in assembly, it’s `_start`.
- `section .text`
    - Indicates that the following lines are the **code section** (executable instructions).
- `_start:`
    - A **label** marking the program’s entry point.
    - When the program runs, the CPU begins executing instructions from here.
- `mov rax, 60`
    - On Linux x86-64, the `rax` register holds the **system call number**.
    - `60` corresponds to the `exit` system call.
    - So this line tells the OS: _I want to exit_.
- `mov rdi, 42`
    - The first argument of a system call is passed in the `rdi` register.
    - For `exit`, this argument is the **exit code**.
    - Here it is set to `42`.
- `syscall`
    - Executes the actual system call.
    - The OS terminates the program and returns the exit code `42`.

```zsh
nasm -f elf64 simple.asm -o simple.o
ld simple.o -o simple
./simple; echo $?
```

## Compilation Stages (in order)
### 1. Preprocessing
    - Handles `#include`, macro substitution, etc.

### 2. Compiling `.c` -> `.s`
```zsh
gcc -S hello.c -o hello.s
```
Input: High-level source code (C, C++, Java, etc.)  
Output: Assembly code  
Process: Translate human-readable high-level language into low-level assembly instructions
Tool: C compiler (e.g., `gcc`, `clang`)

### 3. Assembling `.s/.asm`-> `.o`
```zsh
nasm -f elf64 simple.asm -o simple.o
```

Both `.asm` and `.s` = assembly source code.
- `.asm` → typically hand-written (NASM/MASM style).
- `.s` → typically compiler-generated (AT&T/GAS syntax), but still text assembly you can read/edit.

- Input: Assembly code (`.s` / `.asm`)
- Output: Object file (`.o` / `.obj`) (contains machine code and symbol information)
- Process: Translate assembly language instructions into binary machine instructions that the CPU can understand
- Tool: Assembler (e.g., `nasm`, `as`)
### 4. Linking
```zsh
ld simple.o -o simple
```
Combine all object files and library files, resolve the addresses of functions and variables, and generate an executable file.

#### Two types of linking:
- Static linking: directly into the final executable
- Dynamic Linking: At runtime, the OS loads the library into memory and links it to your program.
### Three Families of instructions
mov / add / jmp

(1) Data Transfer
- **`mov`**: 
    - `mov rax, 5` → put 5 into  `rax`
    - `mov rbx, rax` →  `rax` copy to `rbx`

(2) Arithmetic / Logic
- **`add`**: 
    - `add rax, 2` → `rax = rax + 2`

(3) Control Flow
- **`jmp`**: jump
- **`cmp` + `je`/`jne`**: like if/else

### Registers in x86-64
| Registers | History Name | x86-64                                                             |
| --------- | ------------ | ------------------------------------------------------------------ |
| **RAX**   | Accumulator  | Function return value; syscall number; arithmetic result           |
| **RBX**   | Base         | General-purpose storage; callee-saved                              |
| **RCX**   | Counter      | Loop counter; 4th argument; shift instructions                     |
| **RDX**   | Data         | **3rd argument; high part of multiplication/division; data registe |
- 64-bit: `RAX`
- 32-bit: `EAX`
- 16-bit: `AX`
- 8-bit high: `AH`
- 8-bit low: `AL`

## Operands
instruction = Opcode + Operands
```asm
mov rax, 5
```
each instructor = Opcode + Operands
- **Opcode** → to do what，eg `mov`、`add`、`sub`。
- **Operands** → to who
### Types of memory operands

### Memory Operands
In assembly instructions, if the operand is a **memory address**, the CPU needs to know **how many bytes to read or write**.  
The assembler uses these **size specifiers** to mark the operand size:
- `byte` → 8 bits = 1 byte
- `word` → 16 bits = 2 bytes    
- `dword` → 32 bits = 4 bytes (double word)
- `qword` → 64 bits = 8 bytes (quad word)
### Immediate Operands

### The `mov` Instruction
The `mov` instruction copies data from a source operand to a destination operand.  
It does not change the source operand.

`mov rax, rdi: `

`mov rcx, [rbp - 16]`: 

`mov rax, 60`: put 60 into Register RAX。
60 is Immediate Operand
- Register → Register: Copy the value from one register to another.
- Memory → Register: Load data from a memory address into a register.
- Register → Memory: Store the value from a register into memory.## The Arithmetic Logical Unit

**Input**: Two operands (from registers or memory), plus control signals (the instruction tells it what to do).
**Output**: The operation result (written back to a register), and the **flags**.

Error:
- `mov [rbx], [rcx]     ; invalid: both operands are memory`
- `add [rbx], [rcx]     ; invalid`
#### Multiplying
- **`mul`** = unsigned multiply
- **`imul`** = signed multiply

| Form                | Semantics           | Example             |
| ------------------- | ------------------- | ------------------- |
| `imul rcx`          | RAX × RCX → RDX:RAX | `imul rcx`          |
| `imul rax, rcx`     | RAX = RAX × RCX     | `imul rax, rcx`     |
| `imul rax, rcx, 10` | RAX = RCX × 10      | `imul rax, rcx, 10` |
#### Dividing
- div
- idiv

- `cqo` = Convert Quadword to Octoword
	- The sign of RAX is extended into RDX. (RDX:RAX)

#### Other Operations
- shl
- shr
- sar

lea reg, mem

`lea` = **Load Effective Address**

## Two's Complement

#### Jump Instructions
`jmp label`
####  Flag register:
- **ZF = Zero Flag**
- last calculate result is **0**：
#### Compare and Test
cmp a, b
test a, b
#### Call and Ret
- **`call`** = save return address + jump to function.
- **`ret`** = pop return address + jump back.
#### Push and Pop
```asm
push rbp ;save old RBP
```

- RBP = Base Pointer

System V AMD64 ABI
#### Syscalls
##### argument
- 1st argument → **RDI**
- 2nd argument → **RSI**
- 3rd argument → **RDX**
- 4th argument → **RCX** (or **R10** for syscalls)
- 5th argument → **R8**
- 6th argument → **R9**
- 7th+ arguments → pushed on the stack

#### Data Sections
```sql
+------------------+
| Stack            |  ← local variables, function call stack
+------------------+
| Heap             |  ← dynamic allocation (malloc/new)
+------------------+
| .bss             |  ← uninitialized global/static variables
+------------------+
| .data            |  ← initialized global/static variables
+------------------+
| .text            |  ← code (instructions)
+------------------+
```