Token
- single char
- multi char
- arbitrary


```c
typedef struct Counted_String
{
    char *data;
    long count;
} Counted_String;

#define counted_str_lit(s) (Counted_String){(s), sizeof(s) - 1}
```

### Dynamic Arrays

```c
int arr[10];
```

```c
typedef struct Token_Array  
{  
	Token *items;  
	long count;  
	long capacity;  
} Token_Array;  

void append_token(Token_Array *arr, Token token) {
    if (arr->count >= arr->capacity) {
        long newcap = arr->capacity ? arr->capacity * 2 : 16;
        void *tmp = realloc(arr->items, newcap * sizeof(*arr->items));
        if (!tmp) {
            fprintf(stderr, "Out of memory while expanding token array\n");
            exit(1);
        }
        arr->items = tmp;
        arr->capacity = newcap;
    }
    arr->items[arr->count++] = token;
}
```

- Q: `long newcap = arr->capacity ? arr->capacity * 2 : 16;`
	- if `arr->capacity` == 0, give 16 byte
	- else `capacity * 2`

### Build Script
```bash
#!/bin/bash
pushd ../build

gcc -ggdb -Wall ../code/jive.c -o jive
ret_val=$?
if [ $ret_val -ne 0 ]; then
    echo ERROR: Failed to build jive
    exit $ret_val
fi

echo Built jive successfully!
popd
```

## Parsing a Jive Program

## Abstract Syntax Tree
It is a **tree structure** that represents the **syntactic structure** of your source code, but in an **abstracted (simplified)** form.

```
fn main() -> int{
	let n: int = 0
	while n < 10 {
		call print_int(n)
		call print_nl()
		set n = n + 1
	}
	return n - 10
}
```

```
Program
└── FnDefinitions
    └── FunctionDefinition(name="main")
        ├── params: [ ]
        ├── return_type: int
        └── body: Block
            ├── Stmt[0]: Let
            │   ├── name: n
            │   ├── type: int
            │   └── init_expr: IntLiteral(0)
            │
            ├── Stmt[1]: While
            │   ├── condition: BinaryExpr("<")
            │   │   ├── left:  Identifier(n)
            │   │   └── right: IntLiteral(10)
            │   └── body: Block
            │       ├── Stmt[0]: Call
            │       │   ├── callee: Identifier(print_int)
            │       │   └── args: [ Identifier(n) ]
            │       ├── Stmt[1]: Call
            │       │   ├── callee: Identifier(print_nl)
            │       │   └── args: [ ]
            │       └── Stmt[2]: Set
            │           ├── target: Identifier(n)
            │           └── value: BinaryExpr("+")
            │               ├── left:  Identifier(n)
            │               └── right: IntLiteral(1)
            │
            └── Stmt[2]: Return
                └── expr: BinaryExpr("-")
                    ├── left:  Identifier(n)
                    └── right: IntLiteral(10)
```

`.jive` → `lexer` → parser → **AST** → **interpreter**

## Linked List
sentinel

#### tradeoffs of DLL
- advantage: traversal forward and backward
- disadvantage: need more space

Latency: 
- Latency is the **time delay** between a request and its response. “waiting time per task.”
Throughput
- Operations per second. Number of things we can have going at once
- How many things per second?

## Tree
- n-array tree
- binary tree
- `list of children` tree

### Code Generate
Traversing the Abstract Syntax tree

→`./test_lexer` simple.jive
→`lexer` → Token 
→ Abstract Syntax Tree → assembly code (simple.asm) → `nasm -felf64 simple.asm`
→ linker → ld simple.o -o simple
