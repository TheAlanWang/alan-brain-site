**Date: Sep 16 2025**
## Basic C
### Data Types:
- unsigned size
- size

### Variable
```c
unsigned char red = 224;
char letter = 'e';
int index = 0;
float weight = 129.5f;
double mass = 5.97219e24;

// %d: decimal integer
printf("red:%u, letter:%c, index:%d \n", red, letter, index); 
printf("weight:%f, mass:%.3f \n", weight, mass);
```

### size of type
```c
long size = sizeof(int); 
```
### Conditions:
```c
int x = 10;

if (x > 0) {
    printf("x is positive\n");
} else if (x == 0) {
    printf("x is zero\n");
} else {
    printf("x is negative\n");
}

while (condition) {
    // code runs while condition is true (non-zero)
}

```

```c
#include <stdio.h>

int main() {
    int x = 10;
    int *p = &x;   // p 保存 x 的地址

    printf("x   = %d\n", x);     // 变量的值
    printf("p   = %p\n", (void*)p);  // p 存的内容（x 的地址）
    printf("*p  = %d\n", *p);    // 解引用，拿到 p 指向的值
    printf("&p  = %p\n", (void*)&p); // p 自己的地址
    printf("&x  = %p\n", (void*)&x); // x 的地址（和 p 一样）

    return 0;
}
// output
x   = 10
p   = 0x7ffee22b98c0
*p  = 10
&p  = 0x7ffee22b98b8
&x  = 0x7ffee22b98c0

```
### Pointer:
`&variable` means "the address of the variable".

```c
int val = 50;
int *ptr = &val;  // ptr stores the address of val
printf("Value of val: %d\n", *ptr); // print val

int x = 10;
printf("%p\n", &x);   // prints the address of x

int *p = &x;   // p store address


int arr[3] = {10, 20, 30};
int *p = arr;          // p = &arr[0]

printf("%d\n", *p);    // 10
printf("%d\n", *(p+1));// 20
printf("%d\n", *(p+2));// 30
```

```c
int* a, b; // a:int* pointer , b: int
int *a, *b;   // a and b are pointers
```

### Array:
#### Declare array
1. Use initialization (`= { ... }`) if you already know the values.
2. **Use element assignment** if values will come later (e.g. from user input, a loop, or a file).

Method 1:
- Use initialization (`= { ... }`) if you already know the values.
```c
int numbers[3];
numbers[0] = 42;
numbers[1] = 69;
numbers[2] = 420;
```
Method 2:
- **Use element assignment** if values will come later (e.g. from user input, a loop, or a file).
```c
int numbers[3] = {42, 69, 420};
```

```c
char letter[] = {'o', 'm', 'g'};
```

#### Get array size

```c
int length = sizeof(numbers) / sizeof(numbers[0]);
printf("Length = %d\n", length);
```

### Strings
```c
const char *str = "HELLO";
// const char str = "HELLO"; // ---Type mismatch
char str[] = "HELLO";        // Stack create array {'H','E','L','L','O','\0'}
```

### Memory Allocate
Static memory:
The Stack:
The Heap:

`malloc` is C’s **dynamic memory allocation function** (**Memory Allocate**).
- **Purpose**: It requests a block of **contiguous memory** from the **heap**, with the size specified in **bytes**.
- **Return value**: A **pointer** (`void*` type) to the beginning of that memory block (often cast to the desired type).
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 5 * int space
    int *arr = (int*) malloc(5 * sizeof(int));

    if (arr == NULL) {   // malloc may fail
        printf("Memory allocation failed!\n");
        return 1;
    }

    // 使用这块空间
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 10;
        printf("%d ", arr[i]);
    }

    // 用完要释放
    free(arr);

    return 0;
}
```

## Basic Structs
```c
struct Person
{
	const char *name; // 8 bytes
	int id;           // 4 bytes
};
```

```
struct Person (16 bytes total)
+-------------------+ 
| name   (pointer)  | 8 bytes
+-------------------+
| id     (int)      | 4 bytes
+-------------------+
| padding           | 4 bytes (for alignment)
+-------------------+
```

### cal struct
```c
struct foo {
    char a;   // 1 byte
			  // ------- padding 3 byte
    int b;    // 4 bytes
    char c;   // 1 byte
			  // ------- padding 7 byte || 16 bytes
    long d;   // 8 bytes (on 64-bit)
			  
    char e;   // 1 byte
              // ------- padding 7 byte || 32 bytes
};
```

```
Offset  Size  Member
0       1     a
1–3     3     padding (align b to 4)
4–7     4     b
8       1     c
9–15    7     padding (align d to 8)
16–23   8     d
24      1     e
25–31   7     padding (struct align to 8)
```


### Initial struct

### enumerations
```c
enum Status {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
};

int main() {
    enum Status s = NOT_FOUND;
    printf("Status code: %d\n", s); // prints 404
}

```


### Unions
All members **share** this same memory.

- A `union`’s size = **the size of its largest member**,
- plus possible **padding** so the union is aligned to the requirement of its largest member.
```c
#include <stdio.h>

union Data {
    int i;
    float f;
    char c;
};

int main() {
    union Data d;

    d.i = 42;
    printf("As int: %d\n", d.i);

    d.f = 3.14;
    printf("As float: %f\n", d.f);

    d.c = 'A';
    printf("As char: %c\n", d.c);

    // Notice: each new assignment overwrites the previous value
    return 0;
}

```

### Discriminated unions (AKA tagged union)
A **discriminated union** is a **`union` combined with a “tag”****(usually an `enum` or `int`)** that tells you which member of the union is currently valid.

```c
struct Token
{
	enum Token_Kind kind;
	union Token_Data data;
};
```

### File IO
```c
FILE *in_file = fopen("src.txt", "rb");
char buffer[1024];
int bytes_read = fread(buffer, 1, sizeof(buffer), in_files);
```

`fread(buffer, 1, sizeof(buffer), in_file);`
- `buffer`: the address of the destination buffer 
	- store `address`
	- `char buffer[1024]` decay to address
- `1`: size_t size
	- `1`, which means reading one byte at a time.
- `sizeof(buffer)`
	- how many “elements” to read
- `in_files`: 
	- `fopen`: return file pointer


## CPU Architecture Basic

CPU <-> RAM

Fetch-Decode-Execute Cycle

### ALU (Arithmetic logical unit)
- **ALU (Arithmetic Logic Unit)** is a core component inside the CPU.

### 3 types of Operands:
CPU 指令里的操作数类型
- Register
	- 寄存器的作用就是：在 CPU 内部存放正在用的数据、地址和控制信息，让 CPU 能够快速执行指令。
- Memory
	- 数据来自内存 (RAM) 的某个地址。
- Immediate
	- 数据就是一个常量，直接写在指令里。

Register
- **General-purpose registers** → hold data and operands for instructions.
- **Special-purpose registers** → control CPU operation (program counter, stack pointer, flags, etc.).
general purpose registers? 
floating point registers


Registers in x86-64
```
   ┌─────────────── 64 bits ───────────────┐
   │                RAX                    │
   ├────────── 32 bits ──────────┤
   │             EAX             │
   ├────── 16 bits ──────┤
   │          AX         │
   ├─ 8 bits ─┬─ 8 bits ─┤
   │    AH    │    AL    │
```

### Caches:
**Cache = high-speed memory**, located between the CPU and main memory (RAM).
- **High-speed memory** between CPU and main RAM.
- Purpose: reduce latency of memory access.
- Levels:
    - **L1 Cache**: Smallest, fastest, per-core.
    - **L2 Cache**: Larger, slower, per-core.
    - **L3 Cache**: Largest, slowest, shared across cores.

### Multi-core CPUS
- 多个核心同时处理 **多个任务**（任务级并行）。
### SIMD (Single Instruction Multiple Data)
- 一个核心一次处理 **多个数据**（数据级并行）。

### Pipelining:
- the execution of an instruction is divided into several stages (e.g., Fetch → Decode → Execute → Write-back).
- instructions are in flight at once
### Branch Prediction:
- Predicts outcome of branches (`if` statements, loops).
- Correct prediction = pipeline stays full.
- Wrong prediction = **pipeline flush** → wasted cycles.
### Out-of-order Execution:
- Instructions don’t always execute strictly in program order.
- CPU reorders them to maximize efficiency while preserving correct results.
- Solves pipeline stalls from data dependencies.
### Virtual Memory:
the operating system keeps a table of mapping from vm address to physical address
- ASLR = Address Space Layout Randomization
- Page Fault
- **TLB (Translation Lookaside Buffer)** = **页表缓存**
- OS may swap pages to disk
### Syscalls (系统调用)
- 是 **用户程序** 和 **操作系统内核 (Kernel)** 之间的接口。
- 当程序需要做 **需要操作系统权限的事情**（比如读文件、访问网络、分配内存），就必须通过 syscall。
### ABI (Application Binary Interface)
- ABI 是给 **编译器 / 链接器 / OS / CPU** 用的。
- Low-level interface between:
    - Application code    
    - Operating system
    - CPU hardware
- Defines calling conventions (how functions pass arguments/return values), register usage, and binary formats.
### Endianness
- Endianness = 多字节数据在内存中的排列顺序
Defines how multi-byte data is stored in memory
- Little-endian: Least significant byte at lowest memory address (used by x86).
- Big-endian: Most significant byte at lowest memory address (used in some networking protocols, older CPUs).