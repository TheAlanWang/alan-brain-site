## Backus-Naur Form (BNF)
**Backus–Naur Form (BNF)** is a **notation** used to describe the **syntax** (the structure) of programming languages and formal languages.

```go
<non-terminal> ::= production
```

```go
<letter> ::
<digit>
<ident_start>
<ident_tail>
<identifier> 

<expr>   ::= <term> | <expr> "+" <term>
<term>   ::= <number> | <term> "*" <number>
<number> ::= "0" | "1" | ... | "9"
```
- `3`
- `3+5`
- `3*7+2`

## Extended Backus-Naur Form (EBNF)
- Q: Why need EBNF?
	- Because it makes grammar definitions **more expressive and human-friendly** while still being formal enough for compilers and parsers.

```ebnf
digit  = "0" | "1" | ... | "9" ;
number = digit { digit } ;
```

## Jive EBNF Grammer
```ebnf
letter = "A"-"Z" | "a"-"z";
digit = "0"-"9";
identifiter = ("_" | letter ), {"_" | letter | digit };
string = "", {? all characters ? - (""| '\n')}, ""

expr_list = expr, {",", expr}
argument_list = "()" | "(", [expr_list] , ")" ;

primitive = ( identifier , { subscript } | number | call_expr) | ("(", expr ,")");
unop = "-" | "~" | "!"
binop = "+" | "-" | "*"
term = { upon }, primitive
expr = term, {binop, term}

call_stmt = "call", call_expr;
let = "let" , identifier , ":" , type , [ "=" , expr ] ;
set = "set", identifier , { subscript}, "=", expr
return = "return" , [ expr ] ;
if = "if" , expr , statement, ["else", statement ] ;
while = 

statement = call_stmt | let | set | return | if | while | block ;
block = "{", {statement}, "}" ;
id_type = identifier, ":", type ;
id_type_list = id_type, {",", id_type} ;
parameter_list = "(", [id_type_list], ")" ;
fn_definition = "fn", identifier, parameter_list, ["->", type], block ;
program = { fn_definition } ;
```

Key idea:
**Lexical analysis**
Q: What do we want out of a Lexer?
- reads input file character by character
- Produces tokens
- Sorts tokens into types
- Store auxiliary data
### Counted Strings
`char *cstr = 'hello'`
```c
typedef struct Counted_String
{
	char *data;
	long count;
} Counted_String;

#define counted_str_lit(s) (Counted_String){(s), sizeof(s) - 1}
#define counted_cstr(s) (Counted_String){(s), strlen(s)}
```
bool strings_match(Counted_String s1, Counted_String s2);
bool starts_with(Counted_String s1, Counted_String prefix);

### Macro vs Function 
- Macro (`#define WORD`)
	- Replaces text during the preprocessing stage.
	- replace the source code, just more convenient
- Function
	- Has **type checking** (parameters and return values).

```c
#include <stdio.h>
#include <string.h>

// 定义结构体
typedef struct {
    char *data;
    long count;
} Counted_String;

// 定义宏函数，用字符串字面量快速生成 Counted_String
#define counted_str_lit(s) (Counted_String){ (s), sizeof(s) - 1 }

// 比较两个 Counted_String 是否相等
int strings_match(Counted_String s1, Counted_String s2) {
    if (s1.count != s2.count) return 0; // 长度不等直接 false
    return strncmp(s1.data, s2.data, s1.count) == 0;
}

int main() {
    Counted_String a = counted_str_lit("hello");
    Counted_String b = counted_str_lit("hello");
    Counted_String c = counted_str_lit("world");

    printf("%s (%ld)\n", a.data, a.count);
    printf("a == b ? %s\n", strings_match(a, b) ? "true" : "false");
    printf("a == c ? %s\n", strings_match(a, c) ? "true" : "false");

    return 0;
}

```

### Dynamic Arrays
- A pointer at a single item
- A pointer plus a account

Initial Dynamic Arrays
```c
int *arr = calloc(n, sizeof(int));
// arr[i] will all be initialized to 0
```
#### Expand Capacity


### Dynamic Memory(heap)
- To get access to more memory at run time, we can allocate it from the "heap"
- Three main functions:
	- `void *malloc(size_t num_bytes);`
	- `void *calloc(size_t num_items, size_t bytes_per_item);`
	- `void *realloc(size_t *old_pointer, size_t new_num_bytes);`
- Don't forget to free memory
	- `void free(void *pointer);`

#### Example
```c
typedef struct Token_array
{
	Token *items;
	long count;
	long capacity;
}Token_array

void append_token(Token_Array *arr, Token token)
{
	if (arr->count >= arr->capacity) {
		arr->capacity *= 2;
		if (arr->capacity == 0) arr->capacity = 16;
		arr->items = realloc(arr->items,
							 arr->capacity*sizeof(*arr->items));
	}
	arr->items[arr->count++] = token;
}

// Token *token = &arr->items[7]; Error
// append_token(arr, new_token);
// printf("kind: %d\n", token->kind)
```


- `typedef` gives a type an alias.

```c
char c = *ptr;
switch (c){
case'a': {
	} breack;
case'b':
case'c':{
	}break;
default:
}
```

### Command Line Arguments in C
```c
#include <studio.h>
int main(int arg_count,  const char **argus)
{
	for (int i = 0; i < arg_count; ++i)
	{
		printf("Arg %d = %s\n", i, args[i]);
	}
	return 0
}
```