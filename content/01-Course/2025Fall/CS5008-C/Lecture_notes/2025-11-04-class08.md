Q: how function pass the parameter?
- System V ABI:(Application Binary Interface)
- how functions call each other on Linux

| Argument  | Register         |
| --------- | ---------------- |
| 1st       | **RDI**          |
| 2nd       | **RSI**          |
| 3rd       | **RDX**          |
| 4th       | **RCX**          |
| 5th       | **R8**           |
| 6th       | **R9**           |
| Remaining | On the **stack** |

```
PUSH c
PUSH b
PUSH a
CALL foo

           ← stack（rsp decreases） from high to low
┌───────────────────────────┐  ← high address
│        main old rbp       │
├───────────────────────────┤
│      return address       │  CALL foo 时自动 push
├───────────────────────────┤
│            a              │  main: PUSH a
├───────────────────────────┤
│            b              │  main: PUSH b
├───────────────────────────┤
│            c              │  main: PUSH c
├───────────────────────────┤
│      foo  old rbp         │  foo: push rbp
├───────────────────────────┤
│ return foo local variables│  foo: sub rsp, locals
└───────────────────────────┘  ← low address
```

### RSP RBP
- `rsp` = stack pointer = Top of stack
- `rbp` = Base Pointer/ Frame Pointer

push X:
```
rsp - 8
[rsp] = x
```

stack downward growing stack

###### Q: What is symbol table?
- symbol table is a map/dictionary
```c
typedef struct Symbol {
    String name;
    Type type;
    long stack_offset;
} Symbol;
```

parser create `symbol table`
- offset: 偏移值
	- 局部变量 → `[rbp - offset]`
	- 函数参数 → `[rbp + offset]`
	- 返回地址 → `[rbp + 8]`

```c
[
  { "x": offset 8 },    ← inner block
  { "a": offset 8,
    "b": offset 16 }     ← function scope
]
```

eg:
```c
let x = ...

offset -= 8
symbol_table_add("x", offset)
```

```c
fn foo(a, b, c)

offset = +16   ; a 在 rbp+16
symbol_table_add("a", +16)

offset += 8    ; b 在 rbp+24
symbol_table_add("b", +24)

offset += 8    ; c 在 rbp+32
symbol_table_add("c", +32)
```

offset = +16   ; a 在 rbp+16
symbol_table_add("a", +16)
###### Q: why a + 16?
```
[rbp]     = saved rbp
[rbp+8]   = return address   ← 已经被 call 占用
```

```
高地址
┌───────────────────────────┐
│ main 的 old rbp           │
├───────────────────────────┤
│ a   ← [rbp+16]            │
├───────────────────────────┤
│ b   ← [rbp+24]            │
├───────────────────────────┤
│ c   ← [rbp+32]            │
├───────────────────────────┤
│ return address ← [rbp+8] │
├───────────────────────────┤
│ saved rbp     ← [rbp]    │
└───────────────────────────┘
low address
```

### cal Levenshtein Distance
Levenshtein Distance = **the minimum number of edits needed to turn one string into another**.
- Insert
- Delete
- Replace

```c
#include <stdio.h>
#include <string.h>

int levenshtein_distance(const char *word1, const char *word2)
{
    // Placeholder implementation
    if (*word1 == '\0')
    {
        return strlen(word2);
    }

    if (*word2 == '\0')
    {
        return strlen(word1);   
    }

    if (*word1 == *word2)
    {
        return levenshtein_distance(word1 + 1, word2 + 1);
    }
        // Characters different -> try 3 choices:

    // 1. Insert b[0] into a → consume 1 char from b
    int insert_cost = 1 + levenshtein_distance(word1, word2 + 1);

    // 2. Delete a[0] → consume 1 char from a
    int delete_cost = 1 + levenshtein_distance(word1 + 1, word2);

    // 3. Replace a[0] with b[0] → consume 1 char both
    int replace_cost = 1 + levenshtein_distance(word1 + 1, word2 + 1);

    // Return minimum
    int min = insert_cost;
    if (delete_cost < min) min = delete_cost;
    if (replace_cost < min) min = replace_cost;

    return min;
}
```

Improve to DP
- Top-Down(memorization)
- Bottom-up
