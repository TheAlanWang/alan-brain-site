- Kafka
	- **Event streaming platform**
	- a distributed commit log used for event streaming
		- producers append events to topic partitions
		- consumers read them as streams using offsets


```
Producer(writes) → Kafka(store & repl) → Consumer(reads,process, commit offsets)
```

- We first choose the desired delivery semantics (e.g., at-least-once). 
- Then we implement it by combining
	- producer settings (acks/retries/idempotence) and 
	- consumer offset commit strategy (commit after processing)
	- plus idempotent downstream writes to tolerate duplicates.

## Delivery semantics
- Delivery models
	- At-most-once (commit → process)
		- processed 0 or 1 time (no duplicates), but can lose messages.
		- How it happens: consumer **commits offset before processing** (or drops on error).
		- Use when: losing an event is acceptable (rare), or you prioritize latency over correctness.
	- At-least-once (process → commit) - most common
		- processed **1 or more** times (no loss), but **duplicates are possible**.
		- How it happens: consumer **processes first, then commits offset**; if it crashes after processing but before commit → it reprocesses.
		- **Use when:** correctness matters; handle duplicates via **idempotency/dedup**.
	- Exactly-once (process + commit + produce)
		- processed exactly 1 time (no loss, no duplicates) from the system’s point of view.
		- In Kafka: achievable with idempotent producer + transactions and careful consumer/processing design (often summarized as “EOS”).
		- Use when: duplicates are very costly and you can afford complexity (payments-like workflows, some stream processing).

## Producer side and Consumer side
- Producer Side:
	- `acks`:
		- `acks=0` (fastest, highest risk of loss)
			1) Producer sends the message
			2) Producer does not wait for any response and treats it as success
		- `acks=1` (leader only, good latency)
			1) Producer sends the message to the partition leader
			2) Leader appends the record to its log
			3) Leader replies OK immediately
		- `acks=all/acks=-1` (strongest durability, higher latency)
			1) Producer sends the message to the leader
			2) Leader appends to its log
			3) Leader waits for acknowledgements from in-sync replicas (ISR)
			4) Once the number of in-sync replicas that have written the record meets **`min.insync.replicas`**,
			5) Leader replies `OK`
	- `retries` (retry on failure)
	- idempotent producer
		- `"enable.idempotence": True`
- Consumer Side
	- poll → process → commit offset (depend on delivery models)


- At-least-once
	- Producer:
		- Set `acks=all` to improve durability
		- Enable `retries` to survive transient network/broker failures (avoid dropping messages).
		- Enable idempotent producer
	- Consumer:
		- Commit offsets only after processing succeeds（core）
		- Make downstream writes idempotent