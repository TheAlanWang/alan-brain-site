Solved/ Hinted/ Peeked
### Jan-19
Plan:
- [[0173.Binary_Search_Tree_Iterator]]
### Jan-18
Plan:
- [[1169.Invalid_Transactions]]: Peeked, with bug, need redo
	- Mistake: compare each transaction under the same name, 
- [[0207.Course_Schedule]]: Solved w/o bug, need improve explanation and edge case
- [[0078.Subsets]]: Solved w bug, 1) boundary wrong 2)wrong time complexity 
Required redo:
- [ ] [[1169.Invalid_Transactions]]

### Jan-09
Review:
- [[0001_Two_Sum]] - Solved, Do in 10mins
- [[1636.Sort_Array_by_Increasing_Frequency]] - Solved
###### LC1636. Extension Problem
> Question:
> - You are given an array logs, where each element represents an activity (or log) code. The same code may appear multiple times.
> - The system processes the logs in order. At each time step i:
	- Consider the prefix logs `[0..i]`
	- Count how many distinct activity codes have appeared so far. The total cost is the sum of these unique counts over all time steps.

Example:
- Input: `logs = [2, 2, 3, 1, 1] (n = 5)`
- A good permutation: `arr = [2, 2, 1, 1, 3]`
- Result: `arr = [1, 1, 2, 2, 3]` cost is 1 + 1 + 2 + 2 + 3 = 9

| []              | distinct | result |
| --------------- | -------- | ------ |
| [1]             | 1        | 1      |
| [1, 1]          | 1        | 2      |
| [1, 1, 2]       | 2        | 4      |
| [1, 1, 2, 2]    | 2        | 6      |
| [1, 1, 2, 2, 3] | 3        | 9      |

1. Restate the problem: Given an int array `logs`, we can permute(reorder) the array. For any reorder array, define cost: for each `i`, `cost_i` is the number of unique values in prefix `array[0...i]`, Total cost is `sum(cost_i)`. Return the minimum cost.
2. The key idea: Sort array from higher frequency to lower, keep unique count low as long as possible. Use `set` to track seen values and sum `len(seen)` each step.
3. Time complexity: O($nlogn$) Space complexity: O(n)
4. Edge case:

Solution:
```python
def minimum_time(logs):
    counter_logs = Counter(logs)
    sorted_logs = sorted(logs, key=lambda x: (-counter_logs[x], x)) # most frequent first
    
    seen = set()
    cost = 0
    for num in sorted_logs:
        seen.add(num)
        cost += len(seen)
    return cost
```

###### LC3. Longest Substring Without Repeating Characters 
[leetcode3](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
Solve Type: Solution, need redo
Mistake: forget sliding window concept (Variable size window)

1. Restate the problem: Given a string of lowercase letters, return the length of the longest substring that contains **no repeated characters**.
2. Key point: Use sliding window with two pointers and a frequency hashmap. 
	Expand window by moving right pointer, if the window become invalid.
	Shrink window by moving left pointer. After window is valid, we update the answer using the current window length.
3. Time Complexity: O(n) Space Complexity: O(n)
4. Edge case:

```
while right < len(string):
	add right 
	while window invalid:
	    remove left
	right += 1
	update answer (when valid)
```

### Jan-10
#### Leetcode
###### Redo: 
LC3 Longest Substring Without Repeating Characters 
- **Invariant:** the current window `s[left:right+1]` contains no duplicate characters.
###### LC242. Valid Anagram - easy
[242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)
Solve Type: Answer
1. Let me restate the problem, Given two strings `t` and `s`, consisting only of lowercase English letters. Anagram means same characters, same frequency but in a different order. return True if `t` is an anagram of `s` otherwise return False.
2. The key point is to first compare length of `s` and `t`.  If they differ, return `False`. Then, use a hashmap to count character frequencies`s` {char: frequency}. Next, loop `t` to decrement `count[char]`. if we finish the loop without failing, return True.
3. Time complexity:  O(n) for hashmap Space complexity: O(n). 
	- If hashmap only store 26 lowercase english letter, the space complexity is O(1)

###### LC424. Longest Repeating Character Replacement
[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)
Solve Type: Answer, Explain not clear
1. Restate problem:
	Given a string, consists only of uppercase English letters and an int `k`. We can *replace* at most `k` times *in any substring* so that all characters in that substring become the same. Return the maximum length of substring.
2. Key point: 
	Invariant (window validity rule): window_size <= most_frequency + k
	We don's decrease `most_frequency` during shrinking, it may become *stale*, but it stays an *upper bound* and the algorithm still finds the correct maximum length.
	Expand window: update counts and `most_freq`
	Shrink window: from left until it is valid
3. Time Complexity: O(n) Space Complexity: O(n)
	Space O(1) for uppercase letters only

###### LC567. Permutation in String
[567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)
Solve Type: Answer, passed the test case but better add `if right_char in need_dic:`, more clear way is using 26-count arrays

1. Restate the problem: Given two strings `s1` and `s2` of lowercase English letters, return `True` if `s2` contains a substring that is a **permutation** of `s1`, meaning it has the same length and the same character counts. Otherwise return `False`.
2. Key Point: sliding window + hashmap
	- First, compare the length between `s1` and `s2`
	- Count the frequency of characters in `s1` as `need`.
	- As the window move right, update the window count
	- Shrink the window when size larger than `len(s1)`
	- Track the frequency of characters in the window, when all match, return True
3. Time Complexity: O(n) Space Complexity: O(1)
4. Edge case: `s1` is longer than `s2`
###### LC347. Top K Frequent Elements - Medium
[347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)
Solve Type: Hint
Mistake: 
- `heapify` is in place and return `None`, run in *O(n)* time
- `heapq.heappop(min_heap)`, run in O($logn$)

1. Restate the problem: Given an integer array and an integer `k`, Return the most frequent elements (order does not matter)
2. Key point: Heap + Hashmap
	- Use hashmap to *count* the frequency of each number
	- Build a min-heap of pair `(-frequency, num)`, *so higher frequency will pop at first*
	- Pop heap *up to* `k` times (or until the heap is empty) and collect the numbers into the result.
3. Complexity:
	- Time Complexity: O($n+k*logn$)
		- Counter is O(n)
		- heapify is O(n)
		- `heappop` is O($k*logn$), pop k times
	- Space: O(m), m is unique numbers
4. Edge case: `k` is larger than `len(nums)`

###### LC5. Longest Palindromic Substring
[5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
Solve Type: Answer. but spend time on debug
Mistake: *incorrectly initialized* `max_len` to 0

1. Restate the problem: Give a string, consists only of lowercase English letters. Return the longest contiguous substring that is palindrome
	*palindromic*: it reads the same forwards and backwards. mirrors around its center.
2. key point: *Every palindrome is built by expanding from its center.
3. Time Complexity: O(n^2) Space: *O(1)* no extra memory
4. Edge case: if all character is unique, return first one

#### BQ: Introduction
Hi, my name is Alan. I am currently a second-year master student in Computer Science at Northeastern University. 

Before my studies here, I graduated from the University of Sydney with a degree in Finance and Big Data, and I also completed a bachelor’s degree in Accounting.

After graduation, I gained about five years of woking experience. I worked as a consultant at Cubewise, which is an IBM partner, and then joined Deloitte as a consultant focused more on data and digital transformation. More recently work experience, I moved into a software engineering role at a financial firm.

Across these experiences, I really enjoyed full-stack development and creating engaging AI applications. I am looking for an internship where I can apply my skills and gaining hands-on experience.

### Jan-11
#### Leetcode
###### LC14. Longest Common Prefix - easy
[14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)
Solve Type: Answer with bug. and not optimal

Mistake: cal min length in list should use `min(len(s) for s in strs)`
1. Restate: Given *a list of* multiple lowercase strings, find the longes prefix that all of them share. Return the common prefix string.
2. Key idea: *Scan* from left to right, all strings must have the same characters as `str[0][i]`. The first mismatch means we have reached the end of the common prefix.
3. Complexity
	- Time complexity: O($m*n$)  `m = min length`, `n = number of strings`
	- Space: O(n)
4. Edge case: if "" in strs or no strs

Explain sliding window `[left, right]`: two types of sliding window, fixed-size and variable-size. 
- Expend window, move right to include a new element into window
- Update window state
- Shrink window: if window violate the rules, move left to restore the rule.
- Update the result. when the window is valid

###### LC468. Validate IP Address - Medium
[468. Validate IP Address](https://leetcode.com/problems/validate-ip-address/)
Solve Type: Solution
Mistake: 
- forget *split* `parts = queryIP.split('.')`
- check whether char appear in the string `if "." in sting`
- `isdigit()`

1. Restate the problem: Give a string. Determine whether it is a valid **IPv4** address, a valid **IPv6** address, or **Neither**.
2. Key idea: decide the format by checking the *delimiter*: Validate the IPv6 parts using a set of hexadecimal characters.
3. Time Complexity: O(n) Space Complexity: O(1)
4. Edge Case: Empty IP

###### LC20. Valid Parentheses - easy
[20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
Solve Type: Answer with bug
Mistake: add all parentheses into stack, only need append left_side

1. Restate the problem: Given a string, containing only parentheses. return True if it is a valid parentheses string (correct matched and properly nested). Otherwise, return False.
2. Key idea: hashmap + stack
	- Use a hash map to store *matching pairs* for **closing** brackets:
	- Use a stack to store opening brackets.
	- *Scan*(loop) the string
		- If the character is an opening bracket, push it onto a stack.
		- If it’s a closing *bracket*, the stack must not be empty and the stack top must match the required opening bracket; 
		- otherwise return `False`.
3. Time: O(n) Space: O(n)
4. Edge case: Empty string

###### LC121. Best Time to Buy and Sell Stock
[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
Solve Type: Answer, not clear explanation

1. Restate the problem: Given an integer array(prices per day), choose one day to buy and a later day to sell stock, return the maximum profit
2. key idea: Max difference with prefix minimum
	Scan the prices once, keep the lowest prices, for each day, sell price - min_buy, track the maximum of profit.
3. Time complexity: O(n) Space: O(1)
4. Edge case: if prices always go down, return 0

###### LC402. Remove K Digits
[402. Remove K Digits](https://leetcode.com/problems/remove-k-digits/)
Solve Type: Strong Hint, weak explanation. better to redo
Mistake: 
- `res = ''.join(stack).lstrip('0')`

1. Restate the problem: give me a integer string `num` and int `k`, remove exactly `k` digits in string, return the smallest possible int
2. Key idea: Monotolic Increasing Stack
	- If the current digit < stack top, have to delete stack top to make the number lexicographically smaller
		(remove larger digit earlier always yields a smaller number than keeping it and removing something later)
	- Leading zero need to remove
3. Time complexity: O(n) Space: O(n)
4. Edge case: `len(num) = k`, return 0

### Jan-12

#### Leetcode
###### Redo: 
- LC3. Answer
- LC424. Longest Repeating Character Replacement - Answer
###### LC102. Binary Tree Level Order Traversal
[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)
Solve Type: Answer, bad explanation

1. Restate the problem: Given a root of a binary tree, traversal tree level by level. return a list of lists, *where each inner lists* contains all values on the same depth.
2. Key idea: BDS with a queue
	Level-order traversal is naturally a BFS problem.Use a queue: push root, then repeatedly pop nodes and push their children.
3. Complexity
	Time complexity: O(n) Space Complexity: O(n)
4. Edge case
	root is None
### Jan-14
#### Leetcode
###### LC1004.Max_Consecutive_Ones_III
- Answered, no bug
- Mistake: Space complexity should be O(1)

### Jan-15
#### Leetcode
[[0200.Number_of_Islands]]
- Solved, explanation was not clear
[[0217.Contains_Duplicate]] 
- Solved
[[0133.Clone_Graph]]
- peeked, with strong hint
	- node is used, name cur instead
- [x] need redo Jan-16

### Jan-16
Redo: 
[[0133.Clone_Graph]] - forget edge case, should return `None`
Review:
[[0695.Max_Area_of_Island]] - Solved, debug
[[0042.Trapping_Rain_Water]] - Solved, need clear explanation and clean code

### Jan-17
Review: [[0912.Sort_an_Array]] - Solved with bug, condition wrong
[[1636.Sort_Array_by_Increasing_Frequency]]

