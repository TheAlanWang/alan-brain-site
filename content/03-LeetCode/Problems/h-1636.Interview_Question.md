---
tags:
  - cm/adobe
---
Link: 
Track: NeetCode150
# Question
### Restate the problem
Given a list of activity logs, each log represents an activity ID.  
	Return the minimum total encoding cost.

Assign unique positive integer codes starting from `1` to each distinct activity such that the total encoding cost is minimized.

sum of (frequency of activity × assigned code)

The *follow-up* limits how many occurrences a single code can cover. We split high-frequency activities into multiple groups of size at most K, then apply the same greedy strategy by assigning smaller codes to larger groups.

---

Method 1
Method 2
## Method
### Approach
- Use a hash map (`Counter`) to count the frequency of each activity.
- Sort the frequencies in **descending order**.
- Assign codes `1, 2, 3, ...` to activities from highest to lowest frequency.
- Accumulate the total cost using `frequency × code`.
### Complexity
- Time Complexity: O($nlogn$)
- Space Complexity: O(n)
### Edge Case
- no log return 0
### Code        
```python
from collections import Counter

def find_min(logs):
    freq = Counter(logs)    # {"A": 3}
    sort_freq = sorted(freq.values(), reverse = True) # (3, 2, 1)
    
    cur = 1
    res = 0
    for freq in sort_freq:
        res += freq * cur
        cur += 1
    
    return res

'''
My initial approach assigns codes at the activity level.
However, in the follow-up, the correct unit of assignment is frequency groups of size at most K.

Once I split frequencies into groups, the same greedy strategy still applies.
'''
def find_minwk(logs, k):
    freq = Counter(logs) # {"A": 3}
    sort_freq = sorted(freq.values(), reverse = True) # (3, 2, 1)

    group = [] # [3, 2, 1] -> [2, 1, 2, 1]
    for freq in sort_freq:
        while freq > k:
            group.append(k)
            freq = freq - k
        
        group.append(freq)

    group.sort(reverse = True)
    cur = 1
    res = 0
    for g in group:
        res += g * cur
        cur += 1
    
    return res

if __name__ == "__main__":
    logs = ["B", "B", "A", "A", "A",  "C"]
    print(find_min(logs))
    
    logs = ["B", "B", "A", "A", "A",  "C"]
    res = find_minwk(logs, 2)
    print(res)
```

---
# History
Jan-20-2026 