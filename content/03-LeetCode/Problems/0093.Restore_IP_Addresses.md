---
tags:
  - ds/backt
  - cm/adobe
---
Link: 
Track: NeetCode150
# Question
### Restate the problem

---

Method 1
Method 2
## Method
### Approach
(discussed at lease two approach?)

### Complexity

### Edge Case

### Code        
```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        n = len(s)
 
        def valid_part(part):
            num = int(part)
            if not (0 <= num <= 255):
                return False

            if len(part) > 1 and part[0] == '0':
                return False
            
            return True

        segment = []
        def dfs(start, path):
            if len(path) > 4:
                return

            if start == n and len(path) == 4: 
                segment.append(path[:])
                return
            
            for j in (1, 2, 3): # 0:1, 0:2, 0:3
                end = start + j # end is next start point
                if end > n:
                    break

                part = s[start: end]
                
                if valid_part(part):
                    path.append(part)
                    dfs(end, path)
                    path.pop()

        dfs(0, [])

        res = []
        for address in segment:
            res.append(".".join(address))

        return res
```

---
# History
Jan-21-2026 Hinted
- Spent a long time on deciding correct algorithm
- Got stuck on Boundary, `end` better to set as the next start 