---
tags:
  - ds/sort
  - cm/adobe
company:
  - Adobe
---
Link: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) - Medium

Track: NeetCode150
# Question
### Restate the problem
- Given a list of intervals
- Return a list of merged intervals
- Process: Merge all intervals that overlap
	- If prev_end == next_start, overlap

After sorting by start, you only need to compare the current interval with the **last merged interval**.

---

Method 1: As long as there exists two intervals that overlap, merge them into one interval.
Method 2: sort + use res last index
## Method
### Approach
1. Sort intervals by start time.
    After sorting, any interval that can overlap with the current one must appear **next to it** (or soon after).
2. Greedy merge using the last merged interval.
    Keep a result list `res`. For each interval:
    - If it overlaps with `res[-1]`, merge by extending the end.        
    - Otherwise, start a new interval in `res`.

### Complexity
- Time Complexity: O($nlogn$)
	- sort
- Space Complexity: O(n)
### Edge Case
- if not intervals, return `[]`
### Code
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:

        sort_intervals = sorted(intervals, key = lambda x: (x[0], x[1]))
        n = len(sort_intervals)
        i = 0
        
        res = [sort_intervals[0]]
        for i in range(1, n):
            cur_start, cur_end = sort_intervals[i]

            if res[-1][1] >= cur_start:
                res[-1][1] = max(res[-1][1], cur_end)
            else:
                res.append([cur_start, cur_end])
        
        return res
```

---
# History
Jan-22-2026 Solved w bug 
- not familiar the interval
- remember use `res[0][-1]`
