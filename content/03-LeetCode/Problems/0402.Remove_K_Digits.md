---
tags:
  - ds/stack
  - cm/adobe
company:
  - Adobe
---
Link: 
Track: NeetCode150
# Question
### Restate the problem

---

Method 1
Method 2
## Method
### Approach - monotonic increasing stack
- Use stack to keep digits:
    - Scan digits left â†’ right.
    - While `k > 0` and `stack[-1] > ch`, pop the stack (remove that larger digit), decrement `k`.
    - Push `ch`.
        
- **If k is still > 0 after the scan**, remove from the end (`stack[:-k]`) because the number is already increasing, so the tail digits are the best to delete.
    
- Result: `res = ''.join(stack).lstrip('0')`; if empty return `"0"`

### Complexity
- Time Complexity: O(n)
- Space Complexity: O(n)
### Edge Case
- `k == len(num)`, return "0"

### Code
```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        for char in num:
            while stack and stack[-1] > char and k != 0:
                k -= 1
                stack.pop()
            
            stack.append(char)
        
        if k > 0:
            stack = stack[:-k]

        tmp = ("").join(stack)
        res = tmp.lstrip('0')
        
        return str(res) if res else "0"   
```

---
# History
Jan-22-2026 Solved w bug, took too long time
- `digital string` can compare
- use `while` to deal with stack
- `join()` only work with strings
- `lstrip()` only work with strings, to eliminate `'0'`