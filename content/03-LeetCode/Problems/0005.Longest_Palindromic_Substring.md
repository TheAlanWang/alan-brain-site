---
tags:
  - ds/tp
---
Link: [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) - Medium
Track: NeetCode150
# Question
### Restate the problem
Given a string of lowercase English letters.
Return the longest contiguous *substring* that is palindrome.

- palindromic: it reads the same *forwards* and backwards. mirrors around its center.

---

Method 1: Two pointer (Optimal)
Method 2: Brute Force, check every possible substring. take O($n^3$)
## Method 1: two pointer
### Approach
Every palindrome can be expanded from its **center**.

- Iterate through each index, consider two cases: odd, even
- Use two pointers to expand outward while characters match
- After expansion stops, restore two pointers to get validate palindrome range.
- Track the maximum length and record the substring
### Complexity
- Time Complexity: O($n^2$)
- Space Complexity: O(1)
### Edge Case
- Empty string â†’ return `""`
### Code        
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        max_length = 0
        res = ""

        def expand(left, right):
            while 0 <= left and right < n and s[left] == s[right]:
                left -= 1
                right += 1
            
            return (left + 1, right - 1)

        
        for idx in range(n):
            even_left, even_right = expand(idx, idx + 1)
            odd_left, odd_right = expand(idx, idx)

            if max_length < even_right - even_left + 1:
                max_length = even_right - even_left + 1
                res = s[even_left: even_right + 1]
            
            if max_length < odd_right - odd_left + 1:
                max_length = odd_right - odd_left + 1
                res = s[odd_left: odd_right + 1]

        return res

```

---
# History
Jan-19-2026 Solved w bug, forget to restore pointer